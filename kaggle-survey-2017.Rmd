---
title: "kaggle-survey"
author: "minghao"
date: "October 21, 2017"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: tibble
---

# Libraries
```{r, warning = FALSE, message=FALSE}
require(tidyverse)
require(data.table)
require(lubridate)
require(stringr)
require(ggvis)
require(ggplot2)
require(forcats)
require(ggmap)
require(highcharter)
require(broom)
require(plotly)

#NLP
require(quanteda)
require(wordcloud)
require(slam)

#map
require(leaflet)
```

# Data Input

```{r}

conversionRates <- as.data.table(read.csv(file="conversionRates.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

freeformResponses <- as.data.table(read.csv(file="freeformResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

multipleChoiceResponses <- as.data.table(read.csv(file="multipleChoiceResponses.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = TRUE))

schema <- as.data.table(read.csv(file="schema.csv", strip.white = TRUE, 
                             na.strings=c("","NA"), 
                             stringsAsFactors = FALSE))

```

# Function

```{r}
MultipleChoice_func = function(question, dt = multipleChoiceResponses){
  
  setDT(dt) %>%
    #since the dt contained column with similar name, selecting only these column
    .[, colnames(.) %like% question, with=FALSE] %>%
    # melting wide data into long data
    melt(.,measure.vars=patterns(question), na.rm = TRUE, variable.name=question) %>%
    # Shortening the str with str_extract
    .[, eval(question):=str_extract(get(question), paste0("(?<=",eval(question),")([A-Za-z])*"))] %>%
    .[,.N, by=c(eval(question), "value")] 
}



Wordclourd_func = function(input, dt = freeformResponses){
  
    dfm.txt <-dfm(eval(dt)[!is.na(get(input)), get(input)],
                remove=stopwords("english"),
                remove_symbols = T,
                remove_punct = T,
                remove_numbers = T,
                remove_url = T,
                 ngrams=1:2)
  
  ## Rowsum to find individual term's frequency across all documents
  term_frequency<-row_sums(t(dfm.txt))
  
  ## Create word_freqs
  word_freqs <- data.frame(term = names(term_frequency), num = term_frequency)
  word_freqs
  
  # set.seed(4211)
  # ## Plot wordcloud
  # wordcloud(word_freqs$term, word_freqs$num, max.words = 100,
  #           random.order=FALSE, colors=brewer.pal(8,"Dark2"), rot.per=.3, scale=c(3,.5))
  
}



```


```{r}
colnames(multipleChoiceResponses)
summary(multipleChoiceResponses$EmploymentStatus)
summary(multipleChoiceResponses$CodeWriter)
summary(multipleChoiceResponses$StudentStatus)
summary(multipleChoiceResponses$CareerSwitcher)
summary(multipleChoiceResponses$CurrentJobTitleSelect)
```


# Number of survey respondent with respect to Countries 
```{r}
# t_gender_country <- multipleChoiceResponses %>%
#   .[,.N, by = c("GenderSelect","Country")]
# hchart(t_gender_country, "column", hcaes(x = Country, y = N, group =GenderSelect))



# Merging the records of country for China
# in the raw data, China can be recorded as "People 's Republic of China", "Republic of China"
multipleChoiceResponses<-multipleChoiceResponses[grep("China",Country), Country:= "China"]

# Dropping it from factors too
multipleChoiceResponses<-droplevels(multipleChoiceResponses)

# plotting
hchart(fct_infreq(multipleChoiceResponses$Country), "column")
```
Overall, the majority of the surveyed users are living in US and India. Interestingly, many users also selected "Others" categories ( Or perhaps their country is less represented in the data). There are other platforms like "KDD" and others that may be more popular in Other countries, especially if that country predominately utilize another language (China, Japan)

# Tenure

```{r}
hchart(fct_infreq(multipleChoiceResponses$Tenure), "column")
```

# Job Title

```{r}
hchart(fct_infreq(multipleChoiceResponses$CurrentJobTitleSelect), "column")

# Creating a list of Popular job title for future use, 
AggrJobTitle<-multipleChoiceResponses%>%
  .[!is.na(CurrentJobTitleSelect)&!CurrentJobTitleSelect=="Other",
                        .N, 
    by = CurrentJobTitleSelect] %>%
  .[order(-N)]
```

# Age

```{r}
hchart(multipleChoiceResponses$Age, na.rm =T)
```

```{r}
highchart() %>%
  hc_add_series(density(multipleChoiceResponses[!is.na(Age),Age])) %>%
  hc_xAxis(plotLines = list(
    list(
      value = median(multipleChoiceResponses[!is.na(Age),Age]),
      color = '#ff0000',
      width = 3,
      zIndex = 4,
      label = list(text = paste("Median:", median(multipleChoiceResponses[!is.na(Age),Age])),
                   style = list( color = '#ff0000', fontWeight = 'bold' )
      )),
    list(
      value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]],
      color = '#ff0000',
      width = 3,
      zIndex = 4,
      label = list(text = paste("Q3:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.75)[[1]]),
                   style = list( color = '#ff0000', fontWeight = 'bold' )
      )),
    list(
      value = quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]],
      color = '#ff0000',
      width = 3,
      zIndex = 4,
      label = list(text = paste("Q1:", quantile(multipleChoiceResponses[!is.na(Age),Age], 0.25)[[1]]),
                   style = list( color = '#ff0000', fontWeight = 'bold' )
      ))))
```






# Codes? Who write them

```{r}
t.WTF<-multipleChoiceResponses[!is.na(CurrentJobTitleSelect)] %>%
  .[, .N, by=.(CurrentJobTitleSelect, CodeWriter)] %>%
  .[order(-N)]

hchart(t.WTF, type="column", hcaes(x = CurrentJobTitleSelect, y = N, group = CodeWriter))

  # .[,CurrentJobTitleSelect:=fct_inorder(CurrentJobTitleSelect)]
```


# Job Title
```{r}
t.WTF<-MultipleChoice_func("CurrentJobTitleSelect")
hchart(t.WTF, type="column", hcaes(x = value, y = N, group = value))

```

# Tenure & Experience

Given that Tenure questios can be indicate of experience.

```{r}
schema[Column=="Tenure", Question]
```

Tenure can probably be related to Working Experience, although, this is a hazy indicator given that some might include their numerous years of coding in their education (which typically isn't included in the years of working experience). Sadly, I couldn't find a better indicator in the schema.

```{r}
t.WTF<-MultipleChoice_func("Tenure")
hchart(t.WTF, type="column", hcaes(x = value, y = N))

# Create a numeric column indicative of current tenure selections
# essentially a host of if, then case to set a numeric value fr m.Tenure
multipleChoiceResponses %>%
  .[Tenure=="3 to 5 years", m.Experience :=4] %>%
  .[Tenure=="6 to 10 years", m.Experience :=8] %>%
  .[Tenure=="1 to 2 years", m.Experience :=2] %>%
  .[Tenure=="More than 10 years", m.Experience :=12]%>% 
  #~hand wavingly, though data science being a relatively young field and that the majority of survey user are in their late 20s or early 30, this figures should be alright
  .[Tenure=="Less than a year", m.Experience :=0] %>%
  .[Tenure=="I don't write code to analyze data", m.Experience :=NA]
# perhaps these people rely on tableau and the likes, in any case, this field would not be indicate of their experience in their profession, removing it

## check
# unique(multipleChoiceResponses[,.(m.Experience, Tenure)])

```

# Country vs Compensation Currency, Compensation Amount

## US
```{r}
schema[Column=="Country", Question]
```


```{r}
# Turning CompensationAmountfrom factor into numeric column
multipleChoiceResponses$CompensationAmount <- as.numeric(as.character(multipleChoiceResponses$CompensationAmount))

# Checking if there is significant difference between listing of different of different currecies
multipleChoiceResponses%>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount)]%>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",.(CompensationAmount,CompensationCurrency)] %>%
  # There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? In any case,
  .[, if(.N >10) .SD, by = list(CompensationCurrency)]%>%
  # filtering out those with absurd compensation amount, there are two with 0 or hundreds, selecting only those greater than 10000 (perhaps they are taking internships?)  
  .[CompensationAmount>10000,] %>%
    .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by=CompensationCurrency]

# From the CI ( Q1 - Q3) in this case, I think one can safetly assume that the salary of those living in US but CompensationCurrency==NA can be changed to USD.
multipleChoiceResponses[!is.na(CompensationAmount)&!is.na(CompensationCurrency)&Country=="United States", CompensationCurrency:="USD"]

multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="United States"]


multipleChoiceResponses[!is.na(CompensationAmount)]%>%
  .[Country=="United States",] %>%
  .[,.N,by = c("CompensationCurrency")] 

##bootstrep to check the std.error in mean of different groups
# stat<-function(x, i) {x[i, c(m1 = mean(CompensationAmount))]}
# where<-tempt[, list(list(boot(.SD, stat, R = 10))), by = CompensationCurrency]
# where$V1

```

## India
```{r}

multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="Russia"]


multipleChoiceResponses[!is.na(CompensationAmount),.N,by = c("Country", "CompensationCurrency")] %>%
  .[order(-N)] %>%
  .[Country=="India"]


multipleChoiceResponses%>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount)]%>%
  # Filtering for India, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="India",.(CompensationAmount,CompensationCurrency)] %>%
  # There exist individuals who are taking foreign currency, perhaps they are doing remote work or working overseas? In any case,
  .[, if(.N >10) .SD, by = list(CompensationCurrency)]%>%
  # filtering out those with absurd compensation amount, there are two with 0 or hundreds, selecting only those greater than 10000 (perhaps they are taking internships?)  
  # .[CompensationAmount>10000,]%>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by=CompensationCurrency]

#in this case, the Q1 of those with did not selected currency are significantly different in Q1, given that there are some people who noted that they received USD for compensation, and that we have 443 case of people recieving INR, I think we should err on the safe side and discard those records that did not specified currency for the purpose of compensation analysis.

# This holds true for other countries, where is probably more significant given smaller sample size.

# Ops, it looks like the some people did not select their currency of compensation. There is also a host of people recieving foreign currency ( I wonder if they are doing remote work)
# 
# Though, since we are provided with a .csv of conversion rates and OriginCountry name, lets proceed with joining it together and check if the names match
```


# Currency Codes & Country Name & highcharter Map

```{r}
# library(RCurl)
# x <- getURL("https://gist.githubusercontent.com/marcusbaguley/304261/raw/0ab501897ce32fcd3aecd748b74686a20ada9036/Country%2520Currency%2520Code%2520Mappings")
# y <- read.csv(text = x)

currency2CountryName <- data.table(read.csv("Country Currency Code Mappings.csv"))

#Cleaning up Conversion Rates, removing X which seems to be a raw ID
conversionRates$X=NULL
#Renaming conversionRates to facillate easier join
colnames(conversionRates)<- c("Code", "ExchangeRate")
# joining them together
Currency2CountryConversion<-currency2CountryName[conversionRates, on=.(Code)]

# Converting country code into character
Currency2CountryConversion$CountryCode<-as.character(Currency2CountryConversion$CountryCode)

dt.combined$conv
# Combining the main dt with Currency2Country
dt.combined<-multipleChoiceResponses[!is.na(Country),] %>%
  .[Currency2CountryConversion, on=.(Country)] %>%
  # Create a column that account for the conversion rate of local currencies
  .[!is.na(CompensationAmount),m.CompensationLocal:=CompensationAmount * ExchangeRate]

# Change the columns into character before comparison
dt.combined$Code<-as.character(dt.combined$Code)
dt.combined$CompensationCurrency<-as.character(dt.combined$CompensationCurrency)

# Comparison
unique(dt.combined[CompensationCurrency==Code,.(CompensationCurrency, Code)])

#loading world-geojson that is part of highcharter
data(worldgeojson)

#plotting for highcharter map
hcmap(mapData = worldgeojson, 
      download_map_data=F, data = Currency2CountryConversion, value = "ExchangeRate",
      joinBy = c("iso-a2", "CountryCode"), name = "Demography",
      dataLabels = list(enabled = F, format = '{point.name}'), borderWidth = 1,
      tooltip = list(valueDecimals = 2, valuePrefix = "$", valueSuffix = " USD")) 
```


```{r}
t.WTF<-multipleChoiceResponses[!is.na(CompensationAmount)& Country=="India", .(CompensationAmount,CompensationCurrency,m.Experience)] %>%
  .[is.na(CompensationCurrency)]

highchart() %>%
hc_add_series(density(t.WTF$CompensationAmount))

require(boot)

set.seed(1000)
data <- as.data.table(list(x1 = runif(200,0,10), x2 = runif(200), group = runif(200)>0.5))
stat <- function(x, i) {x[i, c(m1 = mean(x1), m2 = mean(x2))]}
tempt<-data[, list(list(boot(.SD, stat, R = 10))), by = group]$V1

unique(multipleChoiceResponses[,.(Country)])
```



```{r}

colnames(conversionRates)<- c("x", "Country", "exchangeRate")
multipleChoiceResponses$Country
multipleChoiceResponses[conversionRates, on=.(Country)] %>%
  .[,.(conversionRates, Country)]
```

# Pay Package

## Experience Growth

```{r}
multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure)] %>%
  .[order(Tenure)]


t.WTF <- multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",]

  
hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical


# hchart(t.WTF, type="boxplot", hcaes(x = CompensationAmount, y = Tenure))
```

## Experience & Education

It seems only reasonable to restrict pay packages to individual country (or cities) and local currency.


```{r}
multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, FormalEducation)] %>%
  .[order(FormalEducation,Tenure)]

# plot of hcboxplot
hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$FormalEducation,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical

```

## Experience & Job Title

Salary with respect to job title and tenure

```{r}
# limiting to top 5 most popular job title
PopularJob <- head(AggrJobTitle$CurrentJobTitleSelect,5)

multipleChoiceResponses %>%
  # Considering only those with non NA compensationAmount
  .[!is.na(CompensationAmount) & CompensationCurrency=="USD"] %>%
  # Filtering for United States, and also narrowing down to CompensationAmount, CompensationCurrency
  .[Country=="United States",] %>%
  .[CurrentJobTitleSelect %in% PopularJob,] %>%
  .[,list(.N, 
          Median=median(CompensationAmount),
          Q1=quantile(CompensationAmount, 0.25),
          Q3=quantile(CompensationAmount, 0.75)
          ), by =list(Tenure, CurrentJobTitleSelect)] %>%
  .[order(CurrentJobTitleSelect, Tenure)]


# plot of hcboxplot
hcboxplot(x = t.WTF$CompensationAmount, var = t.WTF$Tenure, var2 = t.WTF$CurrentJobTitleSelect,
          outliers = FALSE) %>% 
  hc_chart(type = "column") # to put box vertical


```

# Past Job title
##Select

```{r}
schema[Column=="PastJobTitlesSelect", Question]

hchart(fct_infreq(multipleChoiceResponses$PastJobTitlesSelect), "column")

t.WTF<-multipleChoiceResponses%>%
  .[,if(.N> 50).SD, by = PastJobTitlesSelect]
  # .[order(-num)] %>%

hchart(t.WTF, "column")
```


## FreeForm
```{r}
## freeformResponse
# colnames(freeformResponses)
nrow(freeformResponses[!is.na(PastJobTitlesFreeForm)])
# 2094

t.WTF<-setDT(Wordclourd_func("PastJobTitlesFreeForm")) %>%
  .[order(-num)] %>%
  .[num>20,]

hchart(t.WTF, type="column", hcaes(x = term, y = num))
```



# Learning Platform

```{r}
t.WTF <- MultipleChoice_func("LearningPlatformUsefulness") 
hchart(t.WTF, type="column", hcaes(x = LearningPlatformUse, y = N, group = value))
```

# Work tools Frequency

```{r}
t.WTF <- MultipleChoice_func("WorkToolsFrequency") 
hchart(t.WTF, type="column", hcaes(x = WorkToolsFrequency, y = N, group = value))
```

## Proving your worth for learners

```{r}
schema[Column=="ProveKnowledgeSelect", Question]
```


```{r}
t.WTF <- MultipleChoice_func("ProveKnowledge") 
hchart(t.WTF, type="column", hcaes(x = ProveKnowledge, y = N, group = value))
```

Its equivalent freeform form of data, however, are overwhelming pointing towards projects. Although limited people proceed to free writing this.

```{r}
# nrow(freeformResponses[!is.na(ProveKnowledgeFreeForm)])
# 122

Wordclourd_func("ProveKnowledgeFreeForm")
```

# ImpactfulAlgorithmFreeForm

```{r}
# Checking the valid number of input
# nrow(freeformResponses[!is.na(ImpactfulAlgorithmFreeForm)])
# 4379

# ImpactfulAlgorithmFreeForm
Wordclourd_func("ImpactfulAlgorithmFreeForm")

```


# Choropleths Map

With highcharter maps and geocodes

```{r}
# making a list of file in current working directory
filelist <- list.files()

# if.rds exist, read it , otherwise, identify lat lon for the countries
if(any(filelist=="Country2latlon.rds")){
  # read the created .rds containing the require data
  Country2latlon <- readRDS("Country2latlon.rds")
  colnames(Country2latlon)<- c("CountryName", "lon", "lat")
}else{
  # create a new .rds using geocode to estimate lat and lon of every country
  geocodes <- geocode(as.character(unique(multipleChoiceResponses[!is.na(Country)]$Country)))
  Country2latlon <- data.frame("CountryName" = as.character(unique(multipleChoiceResponses[!is.na(Country)]$Country)),
                               geocodes)
  saveRDS(Country2latlon, "Country2latlon.rds")
}

mapdata <- get_data_from_map(download_map_data("custom/world-highres"))

# glimpse(mapdata)
# $ `hc-group`       <chr> "admin0", "admin0", "admin0", "admin0", "admin0", "admin0", "admin0"...
# $ `hc-middle-x`    <dbl> 0.66, 0.57, 0.70, 0.51, 0.58, 0.33, 0.29, 0.50, 0.41, 0.86, 0.54, 0....
# $ `hc-middle-y`    <dbl> 0.41, 0.58, 0.68, 0.65, 0.41, 0.44, 0.05, 0.52, 0.55, 0.57, 0.51, 0....
# $ `hc-key`         <chr> "fo", "um", "us", "jp", "sc", "in", "fr", "fm", "cn", "sw", "sh", "b...
# $ `hc-a2`          <chr> "FO", "UM", "US", "JP", "SC", "IN", "FR", "FM", "CN", "SW", "SH", "B...
# $ name             <chr> "Faroe Islands", "United States Minor Outlying Islands", "United Sta...
# $ labelrank        <chr> "6", "5", "2", "2", "6", "2", "2", "6", "2", "5", "6", "2", "3", "2"...
# $ `country-abbrev` <chr> "Faeroe Is.", "U.S. MOI", "U.S.A.", "Japan", "Syc.", "India", "Fr.",...
# $ subregion        <chr> "Northern Europe", "Seven seas (open ocean)", "Northern America", "E...
# $ `region-wb`      <chr> "Europe & Central Asia", "East Asia & Pacific", "North America", "Ea...
# $ `iso-a3`         <chr> "FRO", "UMI", "USA", "JPN", "SYC", "IND", "FRA", "FSM", "CHN", "-99"...
# $ `iso-a2`         <chr> "FO", "UM", "US", "JP", "SC", "IN", "FR", "FM", "CN", "SW", "SH", "B...
# $ `woe-id`         <chr> "23424816", "28289407", "23424977", "23424856", "23424941", "2342484...
# $ continent        <chr> "Europe", "North America", "North America", "Asia", "Seven seas (ope...
```

```{r}
# Quick check for uniqueness in Country2latlon by respective longitude and latitude
nrow(unique(setDT(Country2latlon), by=c("lon", "lat")))==nrow(Country2latlon)

# Wow, apparently, geocode gives the same lat and lon for Taiwan and China 
setDT(Country2latlon)[CountryName=="Republic of China"| CountryName=="Taiwan",]

# The Mapdata also does not offer seperate entry for Taiwan,
# lets go for the easier way out - combining them as similar entities.
multipleChoiceResponses <- multipleChoiceResponses[
  Country=="Republic of China"| Country=="Taiwan", Country:="China"]

# Dropping Taiwan from main data too
multipleChoiceResponses$Country<-droplevels(multipleChoiceResponses$Country)

```

```{r}
mean(multipleChoiceResponses$EmploymentStatus=="Employed full-time"|
       multipleChoiceResponses$EmploymentStatus=="Independent contractor, freelancer, or self-employed"|
     multipleChoiceResponses$EmploymentStatus=="Employed part-time"
     , na.rm=T)


mean(multipleChoiceResponses$EmploymentStatus=="Employed full-time"|multipleChoiceResponses$EmploymentStatus=="Employed part-time"
     , na.rm=T)

mean(multipleChoiceResponses$EmploymentStatus=="Independent contractor, freelancer, or self-employed"
     , na.rm=T)


mean(multipleChoiceResponses$CareerSwitcher=="Yes", na.rm=T)
median(multipleChoiceResponses$CareerSwitcher=="Yes", na.rm=T)

#Aggregate the demographics for countries
t.cut<-multipleChoiceResponses[!is.na(Country),] %>%
  .[,.(NCount=.N, 
        AgeMedian = as.numeric(median(Age, na.rm=T)),
        CareerSwitcherP=as.numeric(mean(CareerSwitcher=="Yes", na.rm=T)),
       WorkingP=mean(EmploymentStatus=="Employed full-time"|
                       EmploymentStatus=="Independent contractor, freelancer, or self-employed"|EmploymentStatus=="Employed part-time", na.rm=T),
       LookingForJobP=mean(EmploymentStatus=="Not employed, but looking for work", na.rm=T),
       StudentP=mean(StudentStatus=="Yes", na.rm=T),
       WorkingExpMedian= Median()
   ), 
   by=c("Country")]



```



```{r}

m <- leaflet() %>% setView(lng = 0, lat = 0, zoom = 1)%>%addTiles()


leaflet() %>% addTiles()%>%addProviderTiles(providers$CartoDB.Positron)
```

```{r}

highchart() %>% 
  hc_add_series_map(worldgeojson, GNI2010,
                    value = "GNI", joinBy = "iso3")
```

#Trashes now

```{r}
mpgg <- mpg %>% 
  filter(class %in% c("suv", "compact", "midsize")) %>% 
  group_by(class, manufacturer) %>% 
  summarize(count = n())

categories_grouped <- mpgg %>% 
  group_by(name = class) %>% 
  do(categories = .$manufacturer) %>% 
  list_parse()

highchart() %>% 
  hc_xAxis(categories = categories_grouped) %>% 
  hc_add_series(data = mpgg, type = "bar", hcaes(y = count, color = manufacturer),
                showInLegend = FALSE)


multipleChoiceResponses$LearningPlatformSelect< - as.character(multipleChoiceResponses$LearningPlatformSelect)
  
t.splits <- max(lengths(strsplit(multipleChoiceResponses$LearningPlatformSelect, ",")))

t.test <- multipleChoiceResponses[,.(LearningPlatformSelect)] %>%
  .[, paste0("m.platformSelect", 1:splits):=tstrsplit(LearningPlatformSelect, '\\([^)]+,(*SKIP)(*FAIL)|,\\s*', perl = TRUE)] %>%
  .[, colnames(.) %like% "m.platformSelect",with=FALSE] %>%
  melt(.,  measure.vars = patterns("^m.platformSelect"))
  

hchart(test$value, type="bar")

multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^JobSkillImpo.*", with=FALSE]

multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^LearningCat.*", with=FALSE]

```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkToolsF*", with=FALSE]
```


```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkMethod*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^Time*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^Time*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkData*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^WorkChallenge*", with=FALSE]
```

```{r}
multipleChoiceResponses %>%
.[, colnames(multipleChoiceResponses) %like% "^JobFactor*", with=FALSE]
```

